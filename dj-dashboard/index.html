<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>DJ Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="dj-dashboard.css" />

    <style>
      /* Hide the UI until we know auth status */
      body.auth-checking #app {
        display: none;
      }

      /* Tiny helpers in case your CSS doesn't include them */
      .topbar {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .topbar .spacer {
        flex: 1;
      }
    </style>

    <!-- Firebase v8: ORDER MATTERS. App first, then Auth/Firestore -->
    <script
      src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"
      defer
    ></script>
    <script
      src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"
      defer
    ></script>
    <script
      src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"
      defer
    ></script>
  </head>

  <body class="auth-checking">
    <div id="app">
      <header>
        <div class="topbar">
          <h1>Live Song Requests</h1>
          <span class="spacer"></span>
          <button id="signOutBtn" type="button" aria-label="Sign out">
            Sign out
          </button>
        </div>

        <div class="controls" role="region" aria-label="Filters and sorting">
          <label>
            <span class="sr-only">Status</span>
            <select id="statusFilter">
              <option value="all">All</option>
              <option value="unplayed" selected>Unplayed</option>
              <option value="played">Played</option>
            </select>
          </label>
          <label>
            <span class="sr-only">Sort order</span>
            <select id="sortOrder">
              <option value="mostRequested">Most Requested</option>
              <option value="latestAdded">Latest Added</option>
              <option value="earliestAdded">Earliest Added</option>
              <option value="lastRequested" selected>
                Most Recently Requested
              </option>
            </select>
          </label>
          <label>
            <span class="sr-only">Decade filter</span>
            <select id="decadeFilter">
              <option value="all">All Decades</option>
            </select>
          </label>
          <label>
            <span class="sr-only">Genre filter</span>
            <select id="genreFilter">
              <option value="all">All Genres</option>
            </select>
          </label>
        </div>
      </header>

      <main>
        <div id="feed" class="feed" role="list" aria-live="polite"></div>
      </main>

      <footer class="bottom-controls">
        <button id="exportCsvBtn" type="button">Download CSV</button>
        <button id="clearAllBtn" class="clear-all-btn" type="button">
          Clear All
        </button>
      </footer>
    </div>

    <script>
      // --- CONFIG --- //
      const firebaseConfig = {
        apiKey: "AIzaSyBLZp3f5WAWkAJDpBidh-C2mib2nhnLys4",
        authDomain: "song-request-a8a68.firebaseapp.com",
        projectId: "song-request-a8a68",
        storageBucket: "song-request-a8a68.appspot.com",
        messagingSenderId: "522633732679",
        appId: "1:522633732679:web:564894980a2e0484828762",
      };

      window.addEventListener("DOMContentLoaded", () => {
        if (!window.firebase) {
          console.error("Firebase failed to load.");
          return;
        }

        firebase.initializeApp(firebaseConfig);

        // AUTH GUARD
        firebase.auth().onAuthStateChanged((user) => {
          if (!user) {
            window.location.replace("login.html");
            return;
          }

          // Show app now that we know you're signed in
          document.body.classList.remove("auth-checking");

          if (!firebase.firestore) {
            console.error("Firestore failed to load.");
            return;
          }
          const db = firebase.firestore();

          // ELEMENT REFS
          const feed = document.getElementById("feed");
          const clearAllBtn = document.getElementById("clearAllBtn");
          const exportCsvBtn = document.getElementById("exportCsvBtn");
          const statusFilter = document.getElementById("statusFilter");
          const sortOrder = document.getElementById("sortOrder");
          const decadeFilter = document.getElementById("decadeFilter");
          const genreFilter = document.getElementById("genreFilter");
          const signOutBtn = document.getElementById("signOutBtn");

          // SIGN OUT
          signOutBtn?.addEventListener("click", async () => {
            try {
              await firebase.auth().signOut();
              window.location.replace("login.html");
            } catch (e) {
              console.error(e);
            }
          });

          // --- STATE --- //
          const requestsMap = Object.create(null);
          let renderQueued = false;

          // --- UTILITIES --- //
          const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
          function msToTimeAgo(ts) {
            const now = Date.now();
            const diff = clamp(
              Math.floor((now - Number(ts)) / 1000),
              0,
              Number.MAX_SAFE_INTEGER
            );
            if (diff < 60) return diff + "s ago";
            if (diff < 3600) return Math.floor(diff / 60) + "m ago";
            if (diff < 86400) return Math.floor(diff / 3600) + "h ago";
            return Math.floor(diff / 86400) + "d ago";
          }
          function decadeLabel(year) {
            if (!year) return null;
            const start = Math.floor(Number(year) / 10) * 10;
            return `${start}s`;
          }
          function safeUrl(url) {
            try {
              const u = new URL(url);
              return u.protocol === "http:" || u.protocol === "https:"
                ? u.href
                : "#";
            } catch {
              return "#";
            }
          }
          function setChildren(el, children) {
            el.innerHTML = "";
            for (const child of children) el.appendChild(child);
          }
          function option(value, label, selected) {
            const o = document.createElement("option");
            o.value = value;
            o.textContent = label;
            if (selected) o.selected = true;
            return o;
          }

          // --- FILTER POPULATION --- //
          function populateDecadeFilter() {
            const prior = decadeFilter.value;
            const unique = new Set();
            Object.values(requestsMap).forEach((req) => {
              const lbl = decadeLabel(req.releaseYear);
              if (lbl) unique.add(lbl);
            });
            const sorted = [...unique].sort();
            setChildren(decadeFilter, [
              option("all", "All Decades", prior === "all"),
            ]);
            for (const d of sorted)
              decadeFilter.appendChild(option(d, d, d === prior));
          }
          function populateGenreFilter() {
            const prior = genreFilter.value;
            const unique = new Set();
            Object.values(requestsMap).forEach((req) => {
              if (req.genre) unique.add(req.genre);
            });
            const sorted = [...unique].sort((a, b) =>
              String(a).localeCompare(String(b))
            );
            setChildren(genreFilter, [
              option("all", "All Genres", prior === "all"),
            ]);
            for (const g of sorted)
              genreFilter.appendChild(option(g, g, g === prior));
          }

          // --- CARD CREATION --- //
          function createCard(req) {
            const card = document.createElement("article");
            card.className = "card" + (req.fulfilled ? " fulfilled" : "");
            card.dataset.id = req.key;
            card.setAttribute("role", "listitem");

            if (Number(req.count) > 1) {
              const badge = document.createElement("div");
              badge.className = "badge";
              badge.textContent = String(req.count);
              card.appendChild(badge);
            }

            const img = document.createElement("img");
            img.className = "card-thumb";
            img.alt = "Artwork";
            img.decoding = "async";
            img.loading = "lazy";
            img.src = req.artworkUrl || "";
            img.onerror = () => {
              img.src = "";
              img.classList.add("thumb-missing");
            };
            card.appendChild(img);

            const content = document.createElement("div");
            content.className = "card-content";
            const title = document.createElement("div");
            title.className = "card-title";
            title.textContent = req.title || "Unknown title";
            const artist = document.createElement("div");
            artist.className = "card-artist";
            artist.textContent = req.artist || "Unknown artist";
            const meta = document.createElement("div");
            meta.className = "card-metadata";
            const parts = [];
            if (req.genre) parts.push(req.genre);
            if (req.releaseYear) parts.push(String(req.releaseYear));
            meta.textContent = parts.join(" | ");
            const time = document.createElement("div");
            time.className = "card-time";
            time.dataset.ts = String(req.timestamp || 0);
            time.textContent = msToTimeAgo(req.timestamp || Date.now());

            const actions = document.createElement("div");
            actions.className = "card-actions";
            const link = document.createElement("a");
            link.className = "apple-music-link";
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.href = safeUrl(req.appleMusicUrl || "#");
            link.textContent = "Listen on Apple Music";
            const del = document.createElement("button");
            del.type = "button";
            del.className = "delete-link";
            del.textContent = "Delete";
            del.setAttribute("data-action", "delete");
            actions.appendChild(link);
            actions.appendChild(del);

            content.appendChild(title);
            content.appendChild(artist);
            content.appendChild(meta);
            content.appendChild(time);
            content.appendChild(actions);

            const label = document.createElement("label");
            label.className = "checkbox-container";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = "checkbox";
            checkbox.checked = !!req.fulfilled;
            checkbox.setAttribute("data-action", "toggle");
            const checkmark = document.createElement("span");
            checkmark.className = "checkmark";
            label.appendChild(checkbox);
            label.appendChild(checkmark);

            card.appendChild(content);
            card.appendChild(label);
            return card;
          }

          // --- RENDER --- //
          function getFilteredSorted() {
            const status = statusFilter.value;
            const sort = sortOrder.value;
            const decade = decadeFilter.value;
            const genre = genreFilter.value;

            let arr = Object.values(requestsMap);
            if (status === "unplayed") arr = arr.filter((r) => !r.fulfilled);
            if (status === "played") arr = arr.filter((r) => r.fulfilled);
            if (decade !== "all")
              arr = arr.filter((r) => decadeLabel(r.releaseYear) === decade);
            if (genre !== "all") arr = arr.filter((r) => r.genre === genre);

            arr.sort((a, b) => {
              switch (sort) {
                case "mostRequested":
                  return Number(b.count || 0) - Number(a.count || 0);
                case "latestAdded":
                  return Number(b.timestamp || 0) - Number(a.timestamp || 0);
                case "earliestAdded":
                  return Number(a.timestamp || 0) - Number(b.timestamp || 0);
                case "lastRequested":
                  return (
                    Number(b.lastRequested || 0) - Number(a.lastRequested || 0)
                  );
                default:
                  return Number(b.timestamp || 0) - Number(a.timestamp || 0);
              }
            });
            return arr;
          }

          function renderFeed() {
            renderQueued = false;
            const items = getFilteredSorted();
            feed.innerHTML = "";
            const frag = document.createDocumentFragment();
            for (const req of items) frag.appendChild(createCard(req));
            feed.appendChild(frag);
          }
          function scheduleRender() {
            if (renderQueued) return;
            renderQueued = true;
            requestAnimationFrame(renderFeed);
          }
          setInterval(() => {
            const nodes = feed.querySelectorAll(".card-time");
            nodes.forEach((n) => {
              const ts = Number(n.dataset.ts || 0);
              n.textContent = msToTimeAgo(ts);
            });
          }, 60_000);

          // CSV EXPORT
          function escapeCsv(text) {
            if (text === null || text === undefined) return "";
            const s = String(text);
            return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
          }
          function exportRequests() {
            const all = Object.values(requestsMap);
            if (!all.length) return;
            all.sort((a, b) =>
              String(a.artist || "").localeCompare(String(b.artist || ""))
            );
            const header = [
              "Title",
              "Artist",
              "Genre",
              "ReleaseYear",
              "Count",
              "Fulfilled",
              "FirstAddedISO",
              "LastRequestedISO",
              "AppleMusicUrl",
            ];
            const rows = all.map((r) =>
              [
                escapeCsv(r.title),
                escapeCsv(r.artist),
                escapeCsv(r.genre || ""),
                escapeCsv(r.releaseYear || ""),
                escapeCsv(r.count || 0),
                escapeCsv(!!r.fulfilled),
                escapeCsv(
                  r.timestamp ? new Date(Number(r.timestamp)).toISOString() : ""
                ),
                escapeCsv(
                  r.lastRequested
                    ? new Date(Number(r.lastRequested)).toISOString()
                    : ""
                ),
                escapeCsv(r.appleMusicUrl || ""),
              ].join(",")
            );
            const csv = [header.join(","), ...rows].join("\n");
            const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
            const today = new Date().toISOString().slice(0, 10);
            const filename = `song-requests-${today}.csv`;
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            link.remove();
            URL.revokeObjectURL(url);
          }

          // EVENTS
          statusFilter.addEventListener("change", scheduleRender);
          sortOrder.addEventListener("change", scheduleRender);
          decadeFilter.addEventListener("change", scheduleRender);
          genreFilter.addEventListener("change", scheduleRender);
          exportCsvBtn.addEventListener("click", exportRequests);

          clearAllBtn.addEventListener("click", async () => {
            if (!confirm("Clear all song requests?")) return;
            try {
              const snapshot = await db.collection("requests").get();
              const batch = db.batch();
              snapshot.docs.forEach((doc) => batch.delete(doc.ref));
              await batch.commit();
            } catch (err) {
              console.error("Failed to clear requests", err);
              alert("Failed to clear requests. Check console for details.");
            }
          });

          feed.addEventListener("change", (e) => {
            const target = e.target;
            if (!(target instanceof HTMLInputElement)) return;
            if (target.dataset.action !== "toggle") return;
            const card = target.closest(".card");
            if (!card) return;
            const id = card.dataset.id;
            db.collection("requests")
              .doc(id)
              .update({ fulfilled: target.checked })
              .catch((err) => {
                console.error("Update failed", err);
                target.checked = !target.checked;
              });
          });

          feed.addEventListener("click", (e) => {
            const target = e.target;
            if (!(target instanceof HTMLElement)) return;
            if (target.dataset.action !== "delete") return;
            const card = target.closest(".card");
            if (!card) return;
            const id = card.dataset.id;
            const req = requestsMap[id];
            const title = req?.title || "this request";
            const artist = req?.artist ? ` by "${req.artist}"` : "";
            if (
              confirm(
                `Are you sure you want to delete the request for "${title}"${artist}?`
              )
            ) {
              db.collection("requests")
                .doc(id)
                .delete()
                .catch((err) => {
                  console.error("Delete failed", err);
                  alert("Failed to delete.");
                });
            }
          });

          // LIVE SYNC
          db.collection("requests").onSnapshot((snapshot) => {
            snapshot.docChanges().forEach(({ doc, type }) => {
              if (type === "removed") {
                delete requestsMap[doc.id];
              } else {
                requestsMap[doc.id] = { ...doc.data(), key: doc.id };
              }
            });
            populateDecadeFilter();
            populateGenreFilter();
            scheduleRender();
          });

          scheduleRender();
        });
      });
    </script>
  </body>
</html>
