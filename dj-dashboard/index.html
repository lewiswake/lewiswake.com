<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>DJ Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Favicon / App Icons (optional) -->
    <link rel="icon" href="favicon/favicon.ico" type="image/x-icon" />
    <link
      rel="icon"
      href="favicon/favicon-96x96.png"
      type="image/png"
      sizes="96x96"
    />
    <link
      rel="icon"
      href="favicon/favicon-16x16.png"
      type="image/png"
      sizes="16x16"
    />
    <link
      rel="icon"
      href="favicon/favicon-32x32.png"
      type="image/png"
      sizes="32x32"
    />
    <link
      rel="apple-touch-icon"
      href="favicon/apple-touch-icon.png"
      sizes="180x180"
    />
    <link rel="manifest" href="favicon/site.webmanifest" />

    <style>
      :root {
        --bg: #121212;
        --elev-1: #1e1e1e;
        --text: #ffffff;
        --muted: #cfcfcf;
        --muted-2: #9a9a9a;
        --primary: #3b82f6;
        --primary-600: #2563eb;
        --accent: #3e2c6d;
        --accent-700: #2d2050;
        --danger: #e53e3e;
        --danger-600: #c53030;
        --badge-border: var(--elev-1);
        --radius-sm: 8px;
        --radius-md: 12px;
        --space-1: 0.25rem;
        --space-2: 0.5rem;
        --space-3: 0.75rem;
        --space-4: 1rem;
        --space-6: 1.5rem;
        --shadow-1: 0 2px 4px rgba(0, 0, 0, 0.4);
        --transition-fast: 150ms ease;
        --transition-med: 300ms ease;
      }
      * {
        box-sizing: border-box;
      }
      html {
        -webkit-text-size-adjust: 100%;
      }
      body {
        margin: 0;
        padding: var(--space-4);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
        background-color: var(--bg);
        color: var(--text);
      }
      h1 {
        font-size: 1.5rem;
        text-align: center;
        margin: 0 0 var(--space-4);
        flex: 1 1 auto;
        min-width: 0;
      }
      .sr-only {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: var(--space-4);
        margin-bottom: var(--space-4);
      }
      select,
      button {
        border-radius: var(--radius-sm);
        font-size: 1rem;
      }
      select {
        background: #fff;
        color: #222;
        border: 1px solid #ccc;
        padding: var(--space-2) var(--space-4);
        appearance: auto;
      }
      button {
        background: var(--accent);
        color: #fff;
        border: 0;
        padding: var(--space-2) var(--space-4);
        cursor: pointer;
        transition: background-color var(--transition-fast),
          transform var(--transition-fast);
      }
      button:hover {
        background: var(--accent-700);
      }
      button:active {
        transform: translateY(1px);
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      #backButton {
        background: var(--elev-1);
        border: 1px solid var(--accent);
        flex-shrink: 0;
      }
      #backButton:hover {
        background: var(--accent-700);
      }
      button:focus-visible,
      select:focus-visible,
      .apple-music-link:focus-visible,
      .delete-link:focus-visible,
      .date-link:focus-visible {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
      }

      .feed {
        display: flex;
        flex-direction: column;
        gap: var(--space-4);
        max-width: 720px;
        margin: 0 auto;
      }
      .date-link {
        display: block;
        background: var(--elev-1);
        padding: var(--space-4) var(--space-6);
        border-radius: var(--radius-md);
        color: var(--text);
        text-decoration: none;
        font-size: 1.25rem;
        font-weight: 600;
        transition: background-color var(--transition-fast),
          transform var(--transition-fast);
        box-shadow: var(--shadow-1);
      }
      .date-link:hover {
        background: var(--accent-700);
        transform: translateY(-2px);
      }
      .date-link small {
        display: block;
        color: var(--muted);
        font-size: 0.875rem;
        margin-top: var(--space-1);
      }

      .card {
        display: flex;
        align-items: center;
        gap: var(--space-4);
        background: var(--elev-1);
        padding: var(--space-4);
        border-radius: var(--radius-md);
        position: relative;
        transition: transform var(--transition-med),
          opacity var(--transition-med);
      }
      .card:hover {
        transform: translateY(-1px);
      }
      .card-thumb {
        width: 80px;
        height: 80px;
        object-fit: cover;
        border-radius: var(--radius-sm);
        background: #2a2a2a;
      }
      .thumb-missing {
        filter: grayscale(1) brightness(0.7);
      }
      .card-content {
        flex: 1 1 auto;
        min-width: 0;
      }
      .card-title {
        font-weight: 600;
        font-size: 1rem;
        line-height: 1.25;
      }
      .card-artist,
      .card-metadata {
        font-size: 0.875rem;
        color: var(--muted);
      }
      .card-time {
        font-size: 0.75rem;
        color: var(--muted-2);
      }
      .requester-tab {
        display: inline-block;
        margin-top: var(--space-2);
        padding: 0.25rem 0.5rem;
        background: #fff;
        color: #000;
        border-radius: 9999px;
        font-size: 0.8125rem;
        font-weight: 600;
        line-height: 1;
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(0, 0, 0, 0.1);
        max-width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .checkbox-container {
        position: relative;
        cursor: pointer;
        user-select: none;
      }
      .checkbox-container input {
        position: absolute;
        inset: 0;
        opacity: 0;
      }
      .checkmark {
        height: 32px;
        width: 32px;
        border-radius: 50%;
        border: 2px solid #ccc;
        display: grid;
        place-items: center;
        transition: border-color var(--transition-fast),
          background-color var(--transition-fast);
      }
      .checkbox-container input:checked ~ .checkmark {
        border-color: var(--primary);
        background-color: color-mix(in srgb, var(--primary) 20%, transparent);
      }
      .checkmark::after {
        content: "";
        display: block;
        height: 18px;
        width: 18px;
        border-radius: 50%;
        background: transparent;
        transition: background-color var(--transition-fast),
          transform var(--transition-fast);
        transform: scale(0.85);
      }
      .checkbox-container input:checked ~ .checkmark::after {
        background: var(--primary);
      }

      .controls button.active {
        background-color: #5d458c;
        border: 1px solid #7c62a8;
      }
      .badge {
        position: absolute;
        top: -8px;
        left: -8px;
        width: 24px;
        height: 24px;
        background: var(--danger);
        color: #fff;
        border-radius: 50%;
        display: grid;
        place-items: center;
        font-size: 0.75rem;
        font-weight: 700;
        z-index: 1;
        border: 2px solid var(--badge-border);
        box-shadow: var(--shadow-1);
      }
      .card-actions {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-4);
        font-size: 0.875rem;
        margin-top: var(--space-2);
      }
      .apple-music-link {
        color: var(--primary);
        text-decoration: none;
      }
      .delete-link {
        color: var(--danger);
        background: transparent;
        border: 0;
        padding: 0;
        font: inherit;
        cursor: pointer;
      }
      .apple-music-link:hover,
      .delete-link:hover {
        text-decoration: underline;
      }

      .bottom-controls {
        display: flex;
        justify-content: center;
        gap: var(--space-4);
        margin-top: var(--space-6);
      }
      .clear-all-btn {
        background: var(--danger);
        color: #fff;
        border: 0;
        padding: 0.75rem 1.5rem;
        border-radius: var(--radius-sm);
        font-size: 1rem;
        cursor: pointer;
        font-weight: 700;
      }
      .clear-all-btn:hover {
        background: var(--danger-600);
      }

      @media (max-width: 768px) {
        .card {
          padding: var(--space-3);
        }
        .card-thumb {
          width: 64px;
          height: 64px;
        }
        .card-actions {
          font-size: 0.75rem;
        }
        h1 {
          font-size: 1.25rem;
        }
        .auth-card {
            padding: 2rem 1rem;
        }
      }

      .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .view-home .controls,
      .view-home .bottom-controls,
      .view-home #backButton {
        display: none;
      }
      .view-home #pageTitle {
        text-align: left;
      }
      .view-date .controls,
      .view-date .bottom-controls,
      .view-date #backButton {
        display: flex;
      }
      .view-date #pageTitle {
        text-align: center;
      }

      /* --- NEW AUTH STYLES --- */
      .auth-card-wrapper {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        padding: var(--space-4);
      }
      .auth-card {
        background: var(--elev-1);
        padding: 3rem 2rem;
        border-radius: var(--radius-md);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        width: 100%;
        max-width: 400px;
        text-align: center;
      }
      .auth-title {
        font-size: 1.75rem;
        margin-top: 0;
        margin-bottom: 2rem;
        color: var(--primary);
      }
      .auth-form input {
        display: block;
        width: 100%;
        padding: var(--space-3);
        margin-bottom: var(--space-4);
        border: 1px solid var(--muted-2);
        border-radius: var(--radius-sm);
        background: var(--bg);
        color: var(--text);
        font-size: 1rem;
      }
      .auth-btn {
        width: 100%;
        padding: 0.75rem;
        font-weight: 600;
        border-radius: var(--radius-sm);
        transition: var(--transition-fast);
        margin-bottom: var(--space-3);
        text-align: center;
      }
      .auth-primary {
        background: var(--primary);
        color: #fff;
        border: none;
      }
      .auth-primary:hover {
        background: var(--primary-600);
      }
      .auth-secondary {
        background: transparent;
        color: var(--muted);
        border: 1px solid var(--muted-2);
      }
      .auth-secondary:hover {
        color: var(--text);
        border-color: var(--text);
      }
      .auth-error-message {
        padding: var(--space-3);
        margin-bottom: var(--space-4);
        background-color: var(--danger-600);
        color: var(--text);
        border-radius: var(--radius-sm);
        font-size: 0.9rem;
        text-align: left;
      }

      /* --- NEW DIALOG STYLES (Replacing alert/confirm) --- */
      .custom-dialog-wrapper {
        position: fixed;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.7);
        display: none; /* <-- Set to display: none by default in CSS for safety */
        align-items: center;
        justify-content: center;
        z-index: 2000; /* Higher than auth container */
        padding: var(--space-4);
        backdrop-filter: blur(4px);
      }
      .custom-dialog {
        background: var(--elev-1);
        padding: 2rem;
        border-radius: var(--radius-md);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6);
        width: 100%;
        max-width: 350px;
        text-align: center;
      }
      .custom-dialog h3 {
          color: var(--primary);
          margin-top: 0;
      }
      .dialog-actions {
          display: flex;
          gap: var(--space-3);
          margin-top: 1.5rem;
      }
      .dialog-actions button {
          flex: 1;
          margin: 0; /* Override auth-btn margin */
      }
    </style>
  </head>

  <body>
    <!-- Main Dashboard Application -->
    <div id="app" class="view-home" hidden>
      <header>
        <div class="topbar">
          <button id="backButton" type="button" aria-label="Back to dates">
            &larr; Back
          </button>
          <h1 id="pageTitle">Live Song Requests</h1>
          <span
            id="userBadge"
            style="color: var(--muted); font-size: 0.875rem"
          ></span>
          <button id="signOutBtn" type="button" aria-label="Sign out">
            Sign out
          </button>
        </div>

        <div class="controls" role="region" aria-label="Filters and sorting">
          <label>
            <span class="sr-only">Status</span>
            <select id="statusFilter">
              <option value="all">All</option>
              <option value="unplayed" selected>Unplayed</option>
              <option value="played">Played</option>
            </select>
          </label>
          <label>
            <span class="sr-only">Sort order</span>
            <select id="sortOrder">
              <option value="mostRequested">Most Requested</option>
              <option value="latestAdded">Latest Added</option>
              <option value="earliestAdded">Earliest Added</option>
              <option value="lastRequested" selected>
                Most Recently Requested
              </option>
            </select>
          </label>
          <label>
            <span class="sr-only">Decade filter</span>
            <select id="decadeFilter">
              <option value="all">All Decades</option>
            </select>
          </label>
          <label>
            <span class="sr-only">Genre filter</span>
            <select id="genreFilter">
              <option value="all">All Genres</option>
            </select>
          </label>
        </div>
      </header>

      <main>
        <div id="feed" class="feed" role="list" aria-live="polite"></div>
      </main>

      <footer class="bottom-controls">
        <button id="exportCsvBtn" type="button">Download CSV</button>
        <button id="clearAllBtn" class="clear-all-btn" type="button">
          Clear All
        </button>
      </footer>
    </div>

    <!-- Integrated Login/Sign Up Interface -->
    <div id="authContainer" class="auth-card-wrapper" hidden>
        <div class="auth-card">
            <h2 id="authTitle" class="auth-title">DJ Dashboard Login</h2>
            <div id="authError" class="auth-error-message" hidden></div>

            <form id="authForm" class="auth-form">
                <input type="email" id="emailInput" placeholder="Email" required autocomplete="email" />
                <input type="password" id="passwordInput" placeholder="Password" required autocomplete="current-password" />
                <button id="authPrimaryBtn" type="submit" class="auth-btn auth-primary">Sign In</button>
                <button id="toggleAuthBtn" type="button" class="auth-btn auth-secondary">Need an account? Sign Up</button>
            </form>
        </div>
    </div>

    <!-- Custom Dialog/Modal for Alerts and Confirms (Replacing alert/confirm) -->
    <!-- The 'hidden' attribute is removed here as we control visibility via CSS/JS display property now -->
    <div id="customDialog" class="custom-dialog-wrapper">
        <div class="custom-dialog">
            <h3 id="dialogTitle"></h3>
            <p id="dialogMessage"></p>
            <div id="dialogActions" class="dialog-actions">
                <!-- Buttons are handled in JS to ensure clean listeners -->
                <button id="dialogConfirm" type="button" class="auth-btn auth-primary">Yes</button>
                <button id="dialogCancel" type="button" class="auth-btn auth-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Firebase v11 Modular Imports -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import { getFirestore, collection, doc, updateDoc, deleteDoc, onSnapshot, FieldValue, setDoc, writeBatch, query, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      // Helper to wrap the modular FieldValue
      const serverTimestamp = () => FieldValue.serverTimestamp();

      // --- Custom Dialog Implementation (Replaces alert() and confirm()) ---
      const customDialog = document.getElementById('customDialog');
      const dialogTitle = document.getElementById('dialogTitle');
      const dialogMessage = document.getElementById('dialogMessage');
      const dialogConfirm = document.getElementById('dialogConfirm');
      const dialogCancel = document.getElementById('dialogCancel');
      const dialogActions = document.getElementById('dialogActions');

      function showDialog({ title, message, isConfirm = false }) {
          console.log(`[DIALOG] Showing ${isConfirm ? 'Confirm' : 'Alert'} dialog: ${title} - ${message}`); // Debugging log
          return new Promise(resolve => {
              dialogTitle.textContent = title;
              dialogMessage.textContent = message;
              
              // Only show 'Cancel' button for confirmations
              dialogActions.style.display = isConfirm ? 'flex' : 'block';
              dialogCancel.hidden = !isConfirm;

              // Clone buttons to ensure we only have one-time listeners
              const newConfirm = dialogConfirm.cloneNode(true);
              dialogConfirm.parentNode.replaceChild(newConfirm, dialogConfirm);
              const newCancel = dialogCancel.cloneNode(true);
              dialogCancel.parentNode.replaceChild(newCancel, dialogCancel);

              if (isConfirm) {
                  newConfirm.textContent = "Yes";
                  newConfirm.addEventListener('click', () => {
                      customDialog.style.display = 'none'; // Hide dialog
                      resolve(true);
                  }, { once: true });
                  newCancel.addEventListener('click', () => {
                      customDialog.style.display = 'none'; // Hide dialog
                      resolve(false);
                  }, { once: true });
              } else {
                  // For alerts, the 'Yes' button acts as an 'OK' button
                  newConfirm.textContent = "OK";
                  newConfirm.addEventListener('click', () => {
                      customDialog.style.display = 'none'; // Hide dialog
                      resolve(true);
                  }, { once: true });
              }
              customDialog.style.display = 'flex'; // Show dialog
          });
      }
      window.customAlert = (message) => showDialog({ title: "Notification", message, isConfirm: false });
      window.customConfirm = (message) => showDialog({ title: "Confirm Action", message, isConfirm: true });


      window.addEventListener("DOMContentLoaded", () => {
        
        // --- CONFIG & INITIALIZATION (using global variables) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        if (Object.keys(firebaseConfig).length === 0) {
            console.error("Firebase config is missing. Cannot initialize app.");
            document.getElementById("app").innerHTML = `<p style="text-align:center;color:var(--danger);">Configuration error. Please check your Firebase setup.</p>`;
            return;
        }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- ELEMENT REFS ---
        const appElement = document.getElementById("app");
        const userBadge = document.getElementById("userBadge");
        const pageTitle = document.getElementById("pageTitle");
        const backButton = document.getElementById("backButton");
        const feed = document.getElementById("feed");
        const clearAllBtn = document.getElementById("clearAllBtn");
        const exportCsvBtn = document.getElementById("exportCsvBtn");
        const statusFilter = document.getElementById("statusFilter");
        const sortOrder = document.getElementById("sortOrder");
        const decadeFilter = document.getElementById("decadeFilter");
        const genreFilter = document.getElementById("genreFilter");
        const signOutBtn = document.getElementById("signOutBtn");
        // New Auth Refs
        const authContainer = document.getElementById("authContainer");
        const authTitle = document.getElementById("authTitle");
        const authError = document.getElementById("authError");
        const authForm = document.getElementById("authForm");
        const emailInput = document.getElementById("emailInput");
        const passwordInput = document.getElementById("passwordInput");
        const authPrimaryBtn = document.getElementById("authPrimaryBtn");
        const toggleAuthBtn = document.getElementById("toggleAuthBtn");

        // --- STATE ---
        let currentView = "home";
        let selectedDate = null;
        const requestsMap = Object.create(null);
        let renderQueued = false;
        let dateGroups = {};
        let unsubscribeRequests = null;
        let isSigningUp = false; // Auth state toggle

        // --- AUTH LOGIC ---
        function showAuthError(message) {
            authError.textContent = message;
            authError.hidden = false;
        }
        function hideAuthError() {
            authError.hidden = true;
        }

        // 1. Handle Initial Canvas Auth (for background user tracking)
        if (typeof __initial_auth_token !== 'undefined') {
            signInWithCustomToken(auth, __initial_auth_token)
                .catch(async (e) => {
                    console.warn("Initial custom token auth failed. Falling back to anonymous sign-in.", e);
                    await signInAnonymously(auth);
                });
        } else {
            signInAnonymously(auth)
                .catch(e => console.error("Anonymous sign-in failed.", e));
        }

        // 2. Auth State Change Listener (Decides which view to show)
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                // Not signed in -> show login form
                appElement.hidden = true;
                authContainer.hidden = false;
                userBadge.textContent = "Guest";
                if (unsubscribeRequests) {
                    unsubscribeRequests();
                    unsubscribeRequests = null;
                }
                return;
            }
            // Signed in -> show app + subscribe
            authContainer.hidden = true;
            appElement.hidden = false;
            userBadge.textContent = user.email || user.uid || "Signed in";
            subscribeRequests();
            scheduleRender();
        });

        // 3. Login/Signup Toggle
        toggleAuthBtn.addEventListener("click", () => {
            isSigningUp = !isSigningUp;
            authTitle.textContent = isSigningUp ? "DJ Dashboard Sign Up" : "DJ Dashboard Login";
            authPrimaryBtn.textContent = isSigningUp ? "Sign Up" : "Sign In";
            toggleAuthBtn.textContent = isSigningUp ? "Already have an account? Sign In" : "Need an account? Sign Up";
            hideAuthError();
        });

        // 4. Login/Signup Submit
        authForm.addEventListener("submit", async (e) => {
            e.preventDefault();
            hideAuthError();
            const email = emailInput.value;
            const password = passwordInput.value;

            if (!email || !password) {
                showAuthError("Please enter both email and password.");
                return;
            }

            try {
                if (isSigningUp) {
                    await createUserWithEmailAndPassword(auth, email, password);
                } else {
                    await signInWithEmailAndPassword(auth, email, password);
                }
            } catch (error) {
                let errorMessage = "An unknown error occurred.";
                switch (error.code) {
                    case 'auth/user-not-found':
                    case 'auth/wrong-password':
                        errorMessage = 'Invalid email or password.';
                        break;
                    case 'auth/email-already-in-use':
                        errorMessage = 'This email is already in use.';
                        break;
                    case 'auth/weak-password':
                        errorMessage = 'Password should be at least 6 characters.';
                        break;
                    case 'auth/invalid-email':
                        errorMessage = 'The email address is not valid.';
                        break;
                    default:
                        errorMessage = `Authentication failed: ${error.message}`;
                }
                showAuthError(errorMessage);
                console.error("Auth error:", error);
            }
        });

        // 5. Sign Out
        signOutBtn?.addEventListener("click", async () => {
            try {
                await signOut(auth);
            } catch (e) {
                console.error(e);
            }
        });


        // --- UTILITIES ---
        const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
        function msToTimeAgo(ts) {
          const now = Date.now();
          const diff = clamp(
            Math.floor((now - Number(ts)) / 1000),
            0,
            Number.MAX_SAFE_INTEGER
          );
          if (diff < 60) return diff + "s ago";
          if (diff < 3600) return Math.floor(diff / 60) + "m ago";
          if (diff < 86400) return Math.floor(diff / 3600) + "h ago";
          return Math.floor(diff / 86400) + "d ago";
        }
        function decadeLabel(year) {
          if (!year) return null;
          const start = Math.floor(Number(year) / 10) * 10;
          return `${start}s`;
        }
        function safeUrl(url) {
          try {
            const u = new URL(url);
            return u.protocol === "http:" || u.protocol === "https:"
              ? u.href
              : "#";
          } catch {
            return "#";
          }
        }
        function setChildren(el, children) {
          el.innerHTML = "";
          for (const child of children) el.appendChild(child);
        }
        function option(value, label, selected) {
          const o = document.createElement("option");
          o.value = value;
          o.textContent = label;
          if (selected) o.selected = true;
          return o;
        }
        function formatFullDate(ts, options = {}) {
          if (!ts) return null;
          const date = new Date(Number(ts));
          const defaultOptions = {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          };
          return date.toLocaleDateString(undefined, {
            ...defaultOptions,
            ...options,
          });
        }
        function getISODate(ts) {
          if (!ts) return null;
          const date = new Date(Number(ts));
          const year = date.getUTCFullYear();
          const month = String(date.getUTCMonth() + 1).padStart(2, "0");
          const day = String(date.getUTCDate()).padStart(2, "0");
          return `${year}-${month}-${day}`;
        }

        // --- NAVIGATION ---
        function navigateToDate(isoDate) {
          selectedDate = isoDate;
          currentView = "date";
          scheduleRender();
        }
        function navigateHome() {
          selectedDate = null;
          currentView = "home";
          scheduleRender();
        }

        // --- FILTERS ---
        function populateDecadeFilter() {
          const prior = decadeFilter.value;
          const unique = new Set();
          Object.values(requestsMap).forEach((req) => {
            const lbl = decadeLabel(req.releaseYear);
            if (lbl) unique.add(lbl);
          });
          const sorted = [...unique].sort();
          setChildren(decadeFilter, [
            option("all", "All Decades", prior === "all"),
          ]);
          for (const d of sorted)
            decadeFilter.appendChild(option(d, d, d === prior));
        }
        function populateGenreFilter() {
          const prior = genreFilter.value;
          const unique = new Set();
          Object.values(requestsMap).forEach((req) => {
            if (req.genre) unique.add(req.genre);
          });
          const sorted = [...unique].sort((a, b) =>
            String(a).localeCompare(String(b))
          );
          setChildren(genreFilter, [
            option("all", "All Genres", prior === "all"),
          ]);
          for (const g of sorted)
            genreFilter.appendChild(option(g, g, g === prior));
        }

        // --- CARD CREATION ---
        function createCard(req) {
          const card = document.createElement("article");
          card.className = "card" + (req.fulfilled ? " fulfilled" : "");
          card.dataset.id = req.key;
          card.setAttribute("role", "listitem");

          if (Number(req.count) > 1) {
            const badge = document.createElement("div");
            badge.className = "badge";
            badge.textContent = String(req.count);
            card.appendChild(badge);
          }

          const img = document.createElement("img");
          img.className = "card-thumb";
          img.alt = "Artwork";
          img.decoding = "async";
          img.loading = "lazy";
          img.src = req.artworkUrl || "";
          img.onerror = () => {
            img.src = "";
            img.classList.add("thumb-missing");
          };
          card.appendChild(img);

          const content = document.createElement("div");
          content.className = "card-content";
          const title = document.createElement("div");
          title.className = "card-title";
          title.textContent = req.title || "Unknown title";
          const artist = document.createElement("div");
          artist.className = "card-artist";
          artist.textContent = req.artist || "Unknown artist";
          const meta = document.createElement("div");
          meta.className = "card-metadata";
          const parts = [];
          if (req.genre) parts.push(req.genre);
          if (req.releaseYear) parts.push(String(req.releaseYear));
          meta.textContent = parts.join(" | ");
          const time = document.createElement("div");
          time.className = "card-time";
          time.dataset.ts = String(req.timestamp || 0);
          time.textContent = msToTimeAgo(req.timestamp || Date.now());

          // requester tab
          const requesterName =
            req.requesterName ||
            req.requestedBy ||
            req.userName ||
            req.user ||
            req.name ||
            "";
          if (requesterName) {
            const requesterEl = document.createElement("div");
            requesterEl.className = "requester-tab";
            requesterEl.setAttribute("aria-label", "Requested by");
            requesterEl.textContent = String(requesterName);
            content.appendChild(requesterEl);
          }

          const actions = document.createElement("div");
          actions.className = "card-actions";
          const link = document.createElement("a");
          link.className = "apple-music-link";
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          link.href = safeUrl(req.appleMusicUrl || "#");
          link.textContent = "Listen on Apple Music";
          const del = document.createElement("button");
          del.type = "button";
          del.className = "delete-link";
          del.textContent = "Delete";
          del.setAttribute("data-action", "delete");
          actions.appendChild(link);
          actions.appendChild(del);

          content.appendChild(title);
          content.appendChild(artist);
          content.appendChild(meta);
          content.appendChild(time);
          content.appendChild(actions);

          const label = document.createElement("label");
          label.className = "checkbox-container";
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "checkbox";
          checkbox.checked = !!req.fulfilled;
          checkbox.setAttribute("data-action", "toggle");
          const checkmark = document.createElement("span");
          checkmark.className = "checkmark";
          label.appendChild(checkbox);
          label.appendChild(checkmark);

          card.appendChild(content);
          card.appendChild(label);
          return card;
        }

        // --- RENDER ---
        function getFilteredSortedRequests() {
          const status = statusFilter.value;
          const sort = sortOrder.value;
          const decade = decadeFilter.value;
          const genre = genreFilter.value;

          let arr = Object.values(requestsMap);
          if (selectedDate)
            arr = arr.filter((r) => getISODate(r.timestamp) === selectedDate);
          if (status === "unplayed") arr = arr.filter((r) => !r.fulfilled);
          if (status === "played") arr = arr.filter((r) => r.fulfilled);
          if (decade !== "all")
            arr = arr.filter((r) => decadeLabel(r.releaseYear) === decade);
          if (genre !== "all") arr = arr.filter((r) => r.genre === genre);

          arr.sort((a, b) => {
            switch (sort) {
              case "mostRequested":
                return Number(b.count || 0) - Number(a.count || 0);
              case "latestAdded":
                return Number(b.timestamp || 0) - Number(a.timestamp || 0);
              case "earliestAdded":
                return Number(a.timestamp || 0) - Number(b.timestamp || 0);
              case "lastRequested":
                return (
                  Number(b.lastRequested || 0) - Number(a.lastRequested || 0)
                );
              default:
                return Number(b.timestamp || 0) - Number(a.timestamp || 0);
            }
          });
          return arr;
        }

        function renderDateView() {
          const items = getFilteredSortedRequests();
          if (items.length > 0) {
            pageTitle.textContent = formatFullDate(items[0].timestamp);
          } else if (selectedDate) {
            const [y, m, d] = selectedDate.split("-").map(Number);
            pageTitle.textContent = formatFullDate(Date.UTC(y, m - 1, d));
          } else {
            pageTitle.textContent = "Requests";
          }

          feed.className = "feed";
          feed.innerHTML = "";
          const frag = document.createDocumentFragment();
          if (items.length === 0) {
            feed.innerHTML = `<p style="text-align: center; color: var(--muted);">No requests match the current filters.</p>`;
            return;
          }
          for (const req of items) frag.appendChild(createCard(req));
          feed.appendChild(frag);
        }

        function renderHomeView() {
          pageTitle.textContent = "Live Song Requests";
          feed.className = "feed date-list";
          feed.innerHTML = "";

          dateGroups = {};
          Object.values(requestsMap).forEach((req) => {
            const isoDate = getISODate(req.timestamp);
            if (!isoDate) return;
            if (!dateGroups[isoDate]) {
              dateGroups[isoDate] = { count: 0, timestamp: req.timestamp };
            }
            dateGroups[isoDate].count++;
          });

          const sortedDates = Object.keys(dateGroups).sort().reverse();
          if (sortedDates.length === 0) {
            feed.innerHTML = `<p style="text-align: center; color: var(--muted);">No song requests yet.</p>`;
            return;
          }

          const frag = document.createDocumentFragment();
          for (const isoDate of sortedDates) {
            const dateInfo = dateGroups[isoDate];
            const link = document.createElement("a");
            link.className = "date-link new";
            link.href = "#";
            link.dataset.date = isoDate;
            const countText =
              dateInfo.count === 1 ? "1 request" : `${dateInfo.count} requests`;
            link.innerHTML = `${formatFullDate(
              dateInfo.timestamp
            )}<small>${countText}</small>`;
            link.addEventListener("click", (e) => {
              e.preventDefault();
              navigateToDate(isoDate);
            });
            frag.appendChild(link);
          }
          feed.appendChild(frag);
        }

        function render() {
          renderQueued = false;
          document.getElementById("app").className = "view-" + currentView;
          if (currentView === "home") renderHomeView();
          else renderDateView();
        }
        function scheduleRender() {
          if (renderQueued) return;
          renderQueued = true;
          requestAnimationFrame(render);
        }

        setInterval(() => {
          if (currentView === "date") {
            const nodes = feed.querySelectorAll(".card-time");
            nodes.forEach((n) => {
              const ts = Number(n.dataset.ts || 0);
              n.textContent = msToTimeAgo(ts);
            });
          }
        }, 60_000);

        // CSV export helpers
        function escapeCsv(v) {
          const s = String(v ?? "");
          if (/[,\n"]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
          return s;
        }
        function exportRequests() {
          const all = getFilteredSortedRequests();
          if (!all.length) {
            customAlert("No requests to export for this view.");
            return;
          }
          all.sort((a, b) =>
            String(a.artist || "").localeCompare(String(b.artist || ""))
          );
          const header = [
            "Title",
            "Artist",
            "Genre",
            "ReleaseYear",
            "Count",
            "Fulfilled",
            "FirstAddedISO",
            "LastRequestedISO",
            "AppleMusicUrl",
          ];
          const rows = all.map((r) =>
            [
              escapeCsv(r.title),
              escapeCsv(r.artist),
              escapeCsv(r.genre || ""),
              escapeCsv(r.releaseYear || ""),
              escapeCsv(r.count || 0),
              escapeCsv(!!r.fulfilled),
              escapeCsv(
                r.timestamp ? new Date(Number(r.timestamp)).toISOString() : ""
              ),
              escapeCsv(
                r.lastRequested
                  ? new Date(Number(r.lastRequested)).toISOString()
                  : ""
              ),
              escapeCsv(r.appleMusicUrl || ""),
            ].join(",")
          );
          const csv = [header.join(","), ...rows].join("\n");
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
          const dateString =
            selectedDate || new Date().toISOString().slice(0, 10);
          const filename = `song-requests-${dateString}.csv`;
          const link = document.createElement("a");
          const url = URL.createObjectURL(blob);
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(url);
        }

        // --- EVENTS ---
        backButton.addEventListener("click", navigateHome);
        statusFilter.addEventListener("change", scheduleRender);
        sortOrder.addEventListener("change", scheduleRender);
        decadeFilter.addEventListener("change", scheduleRender);
        genreFilter.addEventListener("change", scheduleRender);
        exportCsvBtn.addEventListener("click", exportRequests);

        clearAllBtn.addEventListener("click", async () => {
          let itemsToClear = [];
          let confirmMessage = "";
          if (selectedDate) {
            itemsToClear = getFilteredSortedRequests();
            const dateInfo = dateGroups[selectedDate];
            const dateStr = dateInfo
              ? formatFullDate(dateInfo.timestamp)
              : selectedDate;
            confirmMessage = `Clear all ${itemsToClear.length} requests for ${dateStr}?`;
          } else {
            itemsToClear = Object.values(requestsMap);
            confirmMessage = `Clear *all* ${itemsToClear.length} song requests from *all dates*? This cannot be undone.`;
          }
          if (itemsToClear.length === 0) {
            customAlert("No requests to clear.");
            return;
          }
          
          if (!await customConfirm(confirmMessage)) return;

          try {
            let docsToDelete = [];
            const requestsCol = collection(db, "requests");
            if (selectedDate) {
              itemsToClear.forEach((item) =>
                docsToDelete.push(doc(requestsCol, item.key))
              );
            } else {
              const snapshot = await getDocs(query(requestsCol));
              snapshot.docs.forEach((d) => docsToDelete.push(d.ref));
            }
            
            if (docsToDelete.length === 0) return;
            
            // Batch delete logic (max 500 ops per batch)
            const batchSize = 499;
            for (let i = 0; i < docsToDelete.length; i += batchSize) {
                const batch = writeBatch(db);
                const currentBatchDocs = docsToDelete.slice(i, i + batchSize);
                currentBatchDocs.forEach((ref) => batch.delete(ref));
                await batch.commit();
            }

            if (selectedDate) navigateHome();
          } catch (err) {
            console.error("Failed to clear requests", err);
            customAlert("Failed to clear requests. Check console for details.");
          }
        });

        // Toggle + Delete
        feed.addEventListener("change", (e) => {
          const target = e.target;
          if (!(target instanceof HTMLInputElement)) return;
          if (!target.classList.contains("checkbox")) return;
          const card = target.closest(".card");
          const id = card?.dataset.id;
          if (!id) return;
          const fulfilled = !!target.checked;
          
          // Optimistic update
          if (requestsMap[id]) requestsMap[id].fulfilled = fulfilled; 
          scheduleRender();

          const docRef = doc(db, "requests", id);
          updateDoc(docRef, {
              fulfilled,
              updatedAt: serverTimestamp(),
            })
            .catch((err) => {
              // Fallback for document not existing (shouldn't happen on update)
              return setDoc(docRef, 
                  { fulfilled, updatedAt: serverTimestamp() },
                  { merge: true }
                )
                .catch((err2) => {
                  console.error("Toggle failed", {
                    primary: err,
                    fallback: err2,
                  });
                  if (requestsMap[id]) requestsMap[id].fulfilled = !fulfilled;
                  target.checked = !fulfilled;
                  scheduleRender();
                  customAlert(
                    (err2 && err2.message) ||
                      "Failed to update status. Please try again."
                  );
                });
            });
        });

        feed.addEventListener("click", async (e) => {
          const delBtn = e.target.closest && e.target.closest(".delete-link");
          if (!delBtn) return;
          const card = delBtn.closest(".card");
          const id = card?.dataset.id;
          if (!id) return;
          
          if (!await customConfirm("Delete this request? This cannot be undone.")) return;
          
          deleteDoc(doc(db, "requests", id))
            .catch((err) => {
              console.error("Failed to delete request", err);
              customAlert("Failed to delete. Please try again.");
            });
        });

        // --- LIVE SYNC ---
        function subscribeRequests() {
          if (unsubscribeRequests) {
            unsubscribeRequests();
            unsubscribeRequests = null;
          }
          
          const q = query(collection(db, "requests"));

          unsubscribeRequests = onSnapshot(q,
            (snapshot) => {
              let filtersNeedUpdate = false;
              snapshot.docChanges().forEach(({ doc, type }) => {
                const oldData = requestsMap[doc.id];
                const newData = { ...doc.data(), key: doc.id };

                if (type === "removed") {
                  delete requestsMap[doc.id];
                } else {
                  requestsMap[doc.id] = newData;
                }
                
                if (
                  type === "added" ||
                  oldData?.genre !== newData?.genre ||
                  oldData?.releaseYear !== newData?.releaseYear
                ) {
                  filtersNeedUpdate = true;
                }
              });
              
              if (filtersNeedUpdate) {
                populateDecadeFilter();
                populateGenreFilter();
              }
              scheduleRender();
            },
            (err) => console.error("Live sync error:", err)
          );
        }
      });
    </script>
  </body>
</html>
